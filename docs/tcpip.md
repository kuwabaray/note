# TCP/IP
TCP/IPはprotocol familyの名前。主に以下のプロトコルがある。
- HTTP（アプリケーション層）
- TCP（トランスポート層）
- UDP（トランスポート層）
- IP（ネットワーク層）

以下1から5の流れでネットワーク上にデータが送信される。
1. ボディに送信したいデータをセットして送信サービスを呼ぶ（例:HttpResponse<String> response = client.send(req,handler)）
2. アプリケーション層のプロトコルで決められたヘッダを追加
3. トランスポート層のプロトコルで決められたヘッダを追加
4. ネットワーク層のプロトコルで決められたヘッダを追加
5. 送信

HTTPはsocket APIを介してTCPまたはUDPのサービスを使用する。TCP, UDP, IPはOSに実装されている。
TCP、UDPのサービスはのIPを使ってパケットの送受信を行う。<br>
```
パケット ... ネットワークで送受信される情報
プロトコル ... パケットの中身（内容）, パケット送受信の手順の規定
```
## IP
IPとは、ヘッダにIPアドレスとポート番号を追加することで送信したいアプリケーションを特定するプロトコルである。IPアドレスでサーバーを特定でき、サーバーの各ポートとアプリケーションが使用しているソケットが紐づいているため、IPアドレスとポート番号で送信先を特定できる。

クライアントがhostのIPアドレスを知るにはDNS(domain name system)を使用するのが一般的。DNSサーバーに問い合わせてURLからIPアドレスに変換する。ポート番号はURLから分からないのでwell knownポートを使う(HTTPだったら80など)、または固有のポートを使ってクライアントとホストはポート番号がわかるようにする。
## TCP
パケットの消失や重複、送信順序の入替があった場合に送信元に再要求する。アプリケーション側でパケットロスを考慮する必要がなく信頼性が高い。

### サーバー側の仕組み
```
1. ソケットを開き、接続を受け付けるIPアドレス・ポート番号をソケットに対応づける。
2. クライアントと接続を確立する。
3. 通信する（read(), write()）
4. ソケットを閉じる（close()）
```
#### 1. ソケットを開き、接続を受け付けるIPアドレス・ポート番号をソケットに対応づける。
javaではserverSocketクラスのインスタンスを作成して、ローカルポートとバインドすることで受け付けられる状態にする。

#### 2. クライアントと接続を確立する。
新しいclient接続があるたびにaccept()によってsocketクラスのインスタンスを作成する。
3wayハンドシェイクといい、クライアント・サーバー間で3回接続の要求・確認を行うことで接続が確立される。
#### 3. 通信する（read(), write()）
write()で送信データ（バイト配列）をoutputStreamで送信側キューに書き込む。書き込んだデータは正常に送信完了するまで保持され、パケットロスなどがあれば再使用される。
flush()で送信する。
受信後、受信側のプログラムがread()をすると受信側キューにあるデータをinputStreamから読み込む。

##### 注意点1
flush()は送信側キューのデータを一度に送信し、read()は受信側キューのデータを一度に読み込む。
通知回数を減らすことでコストを下げている(Nagleアルゴリズム)。
これによって複数回write()したデータに対して1回のread()で読み込む場合や、
1回のwrite()で書き出したデータに対して複数回のread()で読み込む場合がある。
以下のような事象が起きる。
```
例：2回のwrite()で2個メッセージを送信したつもりだが、1回のread()で読み込まれ、くっついた1個のメッセージを取得した。
```
対応としては1.区切り文字を入れる、または2.ヘッダーにメッセージのサイズを入れて固定長のヘッダを読んでからサイズに応じてボディを読み込む必要がある。
実際HTTPではレスポンスヘッダーにContent-Lengthを持っている。

##### 注意点2
flush()は受信キューに空きがないとき完了しない。read()のループとwrite()のループを同じスレッドで実行している場合、通信をしているお互いの受信キューに空きがない状態でflush()を行うとデッドロックとなることに注意する。
### クライアント側の仕組み
```
1. ソケットを開き、接続するリモートIPアドレス・ポート番号でホスト側のソケットと接続する。
2. 通信を行なう (read(), write())
3. ソケットを閉じる (close())
```
## UDP
- 転送中に発生したsocketの破損等を検知し破棄する。それを考慮してアプリケーションを実装する必要がある。<br>
→ 送信内容を保証しないためバッファがいらないのでコストが低い。
- UDPはTCPと異なり、送受信の前に接続を確立する必要がない。<br>
→ 接続が必要ないことは少ないデータの送受信のおいて大きなコスト削減であるため、少ないデータ送受信に向いている。
- TCPはcloseするまで1つの宛先としか送受信できないが、UDPは同時に複数の宛先と送受信ができる。
- UDPパケットはヘッダーにサイズの情報を持っており、1回のsend()に対して1回のrecieve()で受け取れるようになっている。
## HTTP
| バージョン | トランスポート層 | 公開年 |
| ---- | ---- | ---- | 
| HTTP/1.1 | TCP | 1997年 |
| HTTP/2 | TCP | 2015年 |
| HTTP/3 | UDP | 2022年 |

## 参考資料
[1] Kenneth L. Calvert,Michael J. Donahoo,小高 知宏「TCP/IPソケットプログラミング Java編」<br>
[2] [Kubota Hideya「ヒヨコでもわかる TCP/IP 入門」](https://zenn.dev/kubo_programmer/books/fa1e01071e7aaa90672d)<br>
