# TCP/IP
TCP/IPはprotocol familyの名前。主に以下のプロトコルがある。
- HTTP（アプリケーション層）
- TCP（トランスポート層）
- UDP（トランスポート層）
- IP（ネットワーク層）

以下1から5の流れでネットワーク上にデータが送信される。
1. ボディに送信したいデータをセットして送信サービスを呼ぶ（例:HttpResponse<String> response = client.send(req,handler)）
2. アプリケーション層のプロトコルで決められたヘッダを追加
3. トランスポート層のプロトコルで決められたヘッダを追加
4. ネットワーク層のプロトコルで決められたヘッダを追加
5. 送信

HTTPはsocket APIを介してTCPまたはUDPのサービスを使用する。TCP, UDP, IPはOSに実装されている。
TCP、UDPのサービスはのIPを使ってパケットの送受信を行う。<br>
```
パケット ... ネットワークで送受信される情報
プロトコル ... パケットの中身（内容）, パケット送受信の手順の規定
```
## IP
IPとは、ヘッダにIPアドレスとポート番号を追加することで送信したいアプリケーションを特定するプロトコルである。IPアドレスでサーバーを特定でき、サーバーの各ポートとアプリケーションが使用しているソケットが紐づいているため、IPアドレスとポート番号で送信先を特定できる。

クライアントがhostのIPアドレスを知るにはDNS(domain name system)を使用するのが一般的。DNSサーバーに問い合わせてURLからIPアドレスに変換する。ポート番号はURLから分からないのでwell knownポートを使う(HTTPだったら80など)、または固有のポートを使ってクライアントとホストはポート番号がわかるようにする。
## TCP
パケットの消失や重複、送信順序の入替があった場合に送信元に再要求する。アプリケーション側でパケットロスを考慮する必要がなく信頼性が高い。

### サーバー側の仕組み
```
1. ソケットを開き、接続を受け付けるIPアドレス・ポート番号をソケットに対応づける
2. クライアントと接続する
3. 通信する
4. ソケットを閉じる
```
#### 1. ソケットを開き、接続を受け付けるIPアドレス・ポート番号をソケットに対応づける
- javaではserverSocketクラスのインスタンスを作成して、ローカルポート（80）とバインドすることで受け付けられる状態にする。

#### 2. クライアントと接続する
- serverSocketはaccept()によって新しいクライアントとの接続を受け取る。
接続毎に新しいスレッドとsocketクラスのインスタンスを作成し、クライアントとの通信を任せる。
これによりTCP通信は80番ポートだけで複数クライアントと通信ができる。

- 3wayハンドシェイクというクライアント・サーバー間で3回接続の要求・確認を行うことで接続が確立される。

#### 3. 通信する
- write()で送信データ（バイト配列）をoutputStreamで送信側キューに書き込む。書き込んだデータは正常に送信完了するまで保持され、パケットロスなどがあれば再使用される。
- flush()で送信する。
- 受信後、受信側のプログラムがread()をすると受信側キューにあるデータをinputStreamから読み込む。

##### ＊ 注意点1: メッセージの境界がない
flush()は送信側キューのデータを一度に送信し、read()は受信側キューのデータを一度に読み込む。
通知回数を減らすことでコストを下げている(Nagleアルゴリズム)。
これによって複数回write()したデータに対して1回のread()で読み込む場合や、
1回のwrite()で書き出したデータに対して複数回のread()で読み込む場合がある。
以下のような事象が起きる。
```
例：2回のwrite()で2個メッセージを送信したつもりだが、1回のread()で読み込まれ、くっついた1個のメッセージを取得した。
```
対応方法は以下いづれか。
1. 区切り文字を入れる。
2. ヘッダーにメッセージのサイズを入れて固定長のヘッダを読んでからサイズに応じてボディを読み込む。<br> (実際HTTPではレスポンスヘッダーにContent-Lengthを持っている。)

##### ＊ 注意点2: 送受信量が多いときデッドロックが起こり得る
flush()は受信キューに空きがないとき完了しない。read()のループとwrite()のループを同じスレッドで実行している場合、通信をしているお互いの受信キューに空きがない状態でflush()を行うとデッドロックとなることに注意する。

### クライアント側の仕組み
```
1. ソケットを開き、接続するリモートIPアドレス・ポート番号でホスト側のソケットと接続する
2. 通信をする
3. ソケットを閉じる
```
チャットアプリでは複数のユーザーとやり取りするために、1つのクライアントから複数の通信をサーバーとする必要がある。
クライアントのIPアドレスが同じでもサーバー側が区別できるように、ポート番号を分けて通信を確立する。

[画像]
## UDP
- 転送中に発生したsocketの破損等を検知し破棄する。それを考慮してアプリケーションを実装する必要がある。<br>
→ 送信内容を保証しないためバッファがいらないのでコストが低い。
- UDPはTCPと異なり、送受信の前に接続を確立する必要がない。<br>
→ 接続が必要ないことは少ないデータの送受信のおいて大きなコスト削減であるため、少ないデータ送受信に向いている。
- TCPはcloseするまで1つの宛先としか送受信できないが、UDPは同時に複数の宛先と送受信ができる。
- UDPパケットはヘッダーにサイズの情報を持っており、1回のsend()に対して1回のrecieve()で受け取れるようになっている。
## HTTP
| バージョン | トランスポート層 | 公開年 |
| ---- | ---- | ---- | 
| HTTP/1.1 | TCP | 1997年 |
| HTTP/2 | TCP | 2015年 |
| HTTP/3 | UDP | 2022年 |

# Socket.io Library
TCP/IPの応用としてチャットアプリに使用されるjavascriptのライブラリSocket.ioの仕組みを記載する。

Socket.ioは[HTTP long-polling](), [WebSocket]()という2つの方法を使って実現される。<br>
WebSocketはlong-pollingよりも最適な双方向通信方法だが、必ず通信を確立できるわけではない。（節WebSocketを参照）
そのためSocket.ioではlong-pollingをデフォルトとし、可能であればWebSocketにアップグレードする。

## HTTP long-polling
前提として、HTTPなので
- TCPを利用する。
- リクエスト-レスポンス アーキテクチャである。

**HTTP Keep-Alive**<br>
HTTPは原則各リクエスト&レスポンスごとに新しいTCP接続を張る。Keep-Aliveが有効な場合、1つのTCP接続を使い続けて複数のリクエスト&レスポンスを行うことでコストを下げる。

**GET**<br>
自分宛にメッセージが来ていないか確認する。
クライアントはサーバーへリクエストを送り、サーバーはメッセージが来たタイミングでレスポンスを返す。

クライアントからのリクエストに対して、サーバーからのレスポンスが一定時間ないと**コネクションタイムアウト**となる（デフォルト30秒）。そのためGETもサーバーがメッセージを待つ時間は最長30秒とし、30秒経ったらクライアントから新しいGETリクエストをする。

**POST**<br>
自分宛てにメッセージを送るときはPOSTを使う。

[画像]
## WebSocket
新しいプロトコルを使用するとき、ファイアウォール、アンチウィルスソフトウェア、プロキシ等の設定で一般的なプロトコル(HTTP, HTTPSなど)以外は弾かれてしまうが、WebSocketはHTTPからアップグレードすることでそれを回避している。

ハンドシェイクのみHTTPで実施する。upgradeヘッダーでWebSocketにアップグレードすることを指定し、成功するとWebSocketの接続が確立されWebSocketでの送受信ができるようになる。

アップグレードしてもファイアウォール等により接続ができない場合もあるので、Socket.ioではデフォルトでlong-pollingを採用している。

**特徴**
- リクエスト-レスポンス アーキテクチャではなく、クライアントからもサーバーからもデータ送信ができるようにすることで
  * よりリアルタイムなメッセージ送受信ができる。
  * リクエストとレスポンスが必要ではないので、通信の回数が減りコストが低い。
- HTTPにくらべてヘッダが小さいため通信コスト（負荷）が低い。

## 参考資料
[1] Kenneth L. Calvert,Michael J. Donahoo,小高 知宏「TCP/IPソケットプログラミング Java編」<br>
[2] [Kubota Hideya「ヒヨコでもわかる TCP/IP 入門」](https://zenn.dev/kubo_programmer/books/fa1e01071e7aaa90672d)<br>
[3] https://socket.io/docs/v3/how-it-works/<br>
[4] [Microsoft 「Windows 8 と WebSocket プロトコル」](https://learn.microsoft.com/ja-jp/archive/msdn-magazine/2012/december/windows-8-networking-windows-8-and-the-websocket-protocol)<br>
[5] https://triple-underscore.github.io/RFC6455-ja.html<br>
